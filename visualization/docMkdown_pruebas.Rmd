---
title: "Monitorización nivel de “salud” de una red corporativa de PC’s"
author: "Juan Carlos, Fco.Javier Motos, Alonso Flores y David Martín"
date: "Junio 2017"
output: html_document
---



 
#####Objetivo de la práctica
 
La práctica consiste en obtener el nivel de salud del parque de PCs en una empresa en función de las vulnerabilidades que tienen.
 
 
#####Condiciones:

Teniendo en cuenta que el CVSS se basa en la combinación de tres métricas, la presente práctica parte del valor BASE asignado a cada vulnerabilidad en su publicación. Este valor se ve modificado por factores TEMPORALES y de ENTORNO. En nuestro caso solo hemos considerado 2 de ellos:
el base y el de entorno.
 
 
###Preguntas a responder
 
####ÁMBITO PC’s
 
- Distribución % equipos por nº vulnerabilidades
- Distribución % por nivel de criticidad
- Salud del parque global
 
####ÁMBITO VULNERABILIDADES
 
- % de vulnerabilidades por criticidad
- Ranking de fabricantes más vulnerables
 
 
####AMBITO APLICACION
 
- Ranking de aplicaciones por nº de vulnerabilidades
- Ranking de aplicaciones por criticidad de vulnerabilidades
 
 
 


 
 
####El flujo planteado es:

 
* Obtener el software instalado de las máquinas de la empresa (se identifican: Nombre del programa y Versión)
* Obtención del listado de CPEs oficiales de dichos programas
* Se realiza un matching entre CPEs y listado de software por cada máquina.
* Obtenemos un listado de CVEs actualizados
* Se realiza un matching entre CVE y los CPE encontrados en el listado de software de cada máquina
* Se establece un sistema de scoring de vulnerabilidades basado en el CVSS y se asigna un valor de “salud” por cada máquina.
* Se visualizar los resultados desde diferentes perspectivas
 
 
 
####NOTA: Para garantizar la presentación de resultados se ha desarrollado un módulo específico para la creación de un entorno simulado partiendo de las siguientes condiciones:


* Fichero con el listado de los programas comprados por la empresa 

* Fichero con los PC’s instalados en la empresa y su criticidad

* Creación de un fichero de vulnerabilidades por software (número aleatorio de vulnerabilidades y también severidad aleatoria)

* Creación de un entorno ficción en el que cada pc tiene un número aleatorio de programas instalados, a partir del cual se genera el fichero final con la relación de software y vulnerabilidades instaladas por pc en la compañía
 
#####Condiciones de dicha función:

  * 100 pc’s
  * 23 programas corporativos
  * n   vulnerabilidades


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
input.dir <- paste(getwd(),sep='/')
```

####_Fuente de datos_

<div align="center">
![Fuente de datos](`r input.dir`/fuentes.jpg)
</div>
</p>

####_Algoritmo y funciones_
<div align="center">
![Algoritmo y funciones](`r input.dir`/algoritmo.jpg)
</div>
</p>


```{r, carrega_packages, include=F}
library(readr)
library(dplyr)
library(ggplot2)

## Asignacion contenido a la variable vulnerabilidades_grah
#getwd("~/ShynyDavid/AF/")
#fichero <- "fichero_simulacion.csv"
#vulnerabilidades_graph = read.table(fichero,header=T,sep=";")
input.dir <- paste(getwd(),"..",'cache',sep='/')
file.name <- 'scoring.ds.cache.RData'
file.fullname <- paste( input.dir,file.name,sep="/")
print(file.fullname)

load(file.fullname)

print(computers.entries.scoring)
vulnerabilidades_graph <- computers.entries.scoring

```
#**Resultados**


## _Gráfico 1_

```{r,grafic_vulnerabilitats,include=F}

cvss_count <-vulnerabilidades_graph %>% group_by(cvss) %>% summarise(n=n())

b_grafic_1 <- ggplot(head(cvss_count, n = 10), aes(x=cvss, y=n, fill=cvss))

# creem grafic amb x com a multiples vendors
grafic_1 <- b_grafic_1 + geom_bar(stat = "identity")

```


```{r cars, echo=F}
grafic_1
```



```{r,grafic_niveles,include=F}

computers_nivel <-vulnerabilidades_graph %>% group_by(nivel) %>% summarise(n=n())

b_grafic_2 <- ggplot(head(computers_nivel, n = 10), aes(x=nivel, y=n, fill=nivel))
##b_grafic_2 <- ggplot(head(computers_nivel, n = 10), aes(x="", y=n, fill=cvss))


# creem grafic amb x com a unic vendor
grafic_2 <- b_grafic_2 + geom_bar(stat = "identity")

# pie chart:
grafic_3 <- grafic_2 + coord_polar("y", start=0)


```



## _Gráfico 2_



```{r grafico, echo=FALSE}

grafic_2


grafic_3
```



## ==================================================================================


```{r,grafic niveles_2,include=F}

# cvss_count <- count(x = vulnerabilidades_grah, cvss, sort = T)
# cvss_count <-vulnerabilidades_grah %>% group_by(cvss) %>% summarise(n=n())
# computers_nivel <-vulnerabilidades_grah %>% group_by(nivel) %>% summarise(n=n())

# b_grafic_1 <- ggplot(head(cvss_count, n = 10), aes(x=cvss, y=n, fill=cvss))
# b_grafic_2 <- ggplot(head(cvss_count, n = 10), aes(x="", y=n, fill=cvss))

# creem grafic amb x com a multiples vendors
# grafic_1 <- b_grafic_1 + geom_bar(stat = "identity")

# creem grafic amb x com a unic vendor
# grafic_2 <- b_grafic_2 + geom_bar(stat = "identity")

# pie chart:
# grafic_3 <- grafic_2 + coord_polar("y", start=0)


```



## Including Plots

You can also embed plots, for example:

```{r grafic, echo=FALSE}
## grafic_3
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
